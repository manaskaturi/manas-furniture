<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>DEMO Furniture Studio — Vijayawada</title>
<style>
  /* ---------- Theme (Apple-like) ---------- */
  :root{
    --bg:#ffffff; --surface:#fbfbfc; --muted:#6b7280; --text:#0f172a;
    --accent:#0ea5a4; --accent2:#60a5fa; --border:rgba(15,23,42,0.06);
    --shadow: 0 10px 30px rgba(12,18,28,0.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,"Segoe UI",Roboto,Arial;color:var(--text);-webkit-font-smoothing:antialiased}
  /* ---------- Header ---------- */
  header{position:fixed;left:0;right:0;top:0;height:64px;padding:0 18px;display:flex;align-items:center;justify-content:space-between;background:var(--surface);border-bottom:1px solid var(--border);z-index:1400;padding-top:env(safe-area-inset-top)}
  .brand{font-weight:800;font-size:16px}
  .sub{font-size:12px;color:var(--muted);font-weight:600}
  /* ---------- Camera / workspace ---------- */
  #cameraWrapper{position:fixed;left:0;right:0;top:64px;bottom:0;background:#f6f8fa;overflow:hidden}
  video#camera, img#bgImage { position:absolute; left:0; top:0; width:100%; height:100%; object-fit:cover; }
  canvas#grid{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:100 }
  #overlay{ position:absolute; left:0; top:0; width:100%; height:100%; z-index:200; pointer-events:auto; touch-action:none; } /* touch-action none -> improved gestures */
  /* ---------- Controls (bottom-right) ---------- */
  #controls{ position:fixed; right:16px; bottom:14px; display:flex; gap:8px; flex-wrap:wrap; z-index:1500 }
  .btn{ border:0; background:#fff; padding:10px 12px; border-radius:10px; box-shadow:var(--shadow); cursor:pointer; font-weight:700; color:var(--text) }
  .btn.primary{ background: linear-gradient(90deg,var(--accent),var(--accent2)); color:#04293a }
  .btn.ghost{ background:transparent; border:1px solid var(--border) }
  .btn.warn{ background:#fff6f6; color:#b91c1c }

  /* ---------- Catalog toggle (mobile-safe) ---------- */
  #catalogToggle{ position:fixed; left:16px; bottom:14px; z-index:1500; padding:10px 14px; border-radius:10px; background:#fff; box-shadow:var(--shadow); cursor:pointer; font-weight:800 }
  @media (max-width:720px){ /* move toggle below header instead of bottom to avoid overlapping with controls */ #catalogToggle{ top:76px; left:12px; bottom:auto } #controls{ right:8px; bottom:12px } }

  /* ---------- Catalog drawer ---------- */
  #catalogDrawer{ position:fixed; left:0; right:0; bottom:0; height:320px; max-height:56vh; background:var(--surface); border-top:1px solid var(--border); box-shadow:0 -18px 40px rgba(0,0,0,0.06); transform:translateY(100%); transition:transform .28s; z-index:1600; padding:12px }
  #catalogDrawer.open{ transform:translateY(0) }
  #catalogHead{ display:flex; justify-content:space-between; align-items:center; margin-bottom:10px }
  #catalogList{ display:flex; gap:12px; overflow-x:auto; padding-bottom:6px; }
  .catalog-item{ min-width:120px; max-width:140px; padding:8px; border-radius:10px; background:rgba(255,255,255,0.98); border:1px solid var(--border); display:flex; flex-direction:column; align-items:center; cursor:pointer; flex-shrink:0 }
  .catalog-thumb{ width:100%; height:76px; display:flex; align-items:center; justify-content:center; margin-bottom:8px }
  .catalog-thumb img{ width:100%; height:100%; object-fit:contain }

  /* ---------- Scene item styling ---------- */
  .item-wrap{ position:absolute; left:0; top:0; transform-origin:center center; will-change:transform; z-index:300; user-select:none; touch-action:none }
  .item-wrap.selected{ box-shadow:0 20px 60px rgba(12,18,28,0.12); border-radius:8px }
  .item-img{ display:block; pointer-events:none; max-width:520px; height:auto; user-select:none }

  /* handles */
  .handle{ position:absolute; width:14px; height:14px; background:#fff; border-radius:4px; box-shadow:0 6px 16px rgba(0,0,0,0.12); transform:translate(-50%,-50%); opacity:0; transition:opacity .12s }
  .item-wrap.selected .handle{ opacity:1 }
  .handle.nw{ left:0; top:0; cursor:nwse-resize }
  .handle.ne{ right:0; top:0; cursor:nesw-resize }
  .handle.sw{ left:0; bottom:0; cursor:nesw-resize }
  .handle.se{ right:0; bottom:0; cursor:nwse-resize }
  .handle.n{ left:50%; top:0; cursor:ns-resize }
  .handle.s{ left:50%; bottom:0; cursor:ns-resize }
  .handle.e{ right:0; top:50%; cursor:ew-resize }
  .handle.w{ left:0; top:50%; cursor:ew-resize }
  .handle.rotate{ top:-28px; left:50%; width:14px; height:14px; background:var(--accent); border-radius:50%; cursor:grab }

  /* toolbar */
  .item-toolbar{ position:absolute; right:8px; top:-46px; display:flex; gap:8px; z-index:400; opacity:0; transform:translateY(-6px); transition:all .12s }
  .item-wrap.selected .item-toolbar{ opacity:1; transform:translateY(0) }
  .tool{ padding:6px 8px; background:rgba(255,255,255,0.98); border-radius:8px; border:1px solid var(--border); font-weight:700; cursor:pointer }

  /* background editor (full-screen overlay element) */
  #bgEditor{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(1); z-index:180; touch-action:none; display:none }
  #bgEditor img{ max-width:2000px; max-height:2000px; width:100%; height:100%; object-fit:cover; display:block; }

  /* small helpers */
  .hidden{ display:none !important }
  /* avoid layout shift on iOS dynamic toolbar - we'll set workspace height by JS */
</style>
</head>
<body>
  <header id="pageHeader">
    <div>
      <div class="brand">DEMO Furniture Studio</div>
      <div class="sub">Vijayawada</div>
    </div>
    <div class="header-right">Prototype — Place & Snapshot</div>
  </header>

  <div id="cameraWrapper" aria-live="polite">
    <img id="bgImage" alt="Background (uploaded)" />
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="grid"></canvas>
    <div id="overlay" aria-label="Scene overlay"></div>
    <!-- background editor -->
    <div id="bgEditor" role="dialog" aria-modal="true">
      <img id="bgEditorImg" alt="Edit background" />
    </div>
  </div>

  <!-- controls -->
  <div id="controls" role="toolbar" aria-label="Controls">
    <button id="startCam" class="btn primary">Start Camera</button>
    <button id="stopCam" class="btn">Stop</button>

    <input id="fileBg" type="file" accept="image/*" />
    <button id="uploadBg" class="btn">Upload Background</button>
    <button id="editBgBtn" class="btn">Edit Background</button>
    <button id="toggleCamBg" class="btn">Use Background</button>

    <input id="fileFurniture" type="file" accept="image/*" />
    <button id="uploadFurniture" class="btn">Upload Item</button>

    <button id="toggleGridBtn" class="btn">Grid</button>
    <button id="enterArBtn" class="btn">Enter AR</button>

    <button id="snapshot" class="btn">Snapshot</button>
    <button id="reset" class="btn warn">Reset</button>
  </div>

  <div id="catalogToggle" aria-controls="catalogDrawer" aria-expanded="false">Catalog</div>

  <div id="catalogDrawer" aria-hidden="true">
    <div id="catalogHead">
      <strong>Catalog</strong>
      <div>
        <button id="addSamples" class="btn">Add Samples</button>
        <button id="closeCatalog" class="btn">Close</button>
      </div>
    </div>
    <div id="catalogList" role="list"></div>
  </div>

<script>
/* ========= Utility & state ========= */
const header = document.getElementById('pageHeader');
const cameraWrapper = document.getElementById('cameraWrapper');
const camera = document.getElementById('camera');
const bgImage = document.getElementById('bgImage');
const overlay = document.getElementById('overlay');
const grid = document.getElementById('grid');
const bgEditor = document.getElementById('bgEditor');
const bgEditorImg = document.getElementById('bgEditorImg');

const startCam = document.getElementById('startCam');
const stopCam = document.getElementById('stopCam');
const fileBg = document.getElementById('fileBg');
const uploadBg = document.getElementById('uploadBg');
const editBgBtn = document.getElementById('editBgBtn');
const toggleCamBg = document.getElementById('toggleCamBg');
const fileFurniture = document.getElementById('fileFurniture');
const uploadFurniture = document.getElementById('uploadFurniture');
const toggleGridBtn = document.getElementById('toggleGridBtn');
const enterArBtn = document.getElementById('enterArBtn');
const snapshotBtn = document.getElementById('snapshot');
const resetBtn = document.getElementById('reset');

const catalogToggle = document.getElementById('catalogToggle');
const catalogDrawer = document.getElementById('catalogDrawer');
const catalogList = document.getElementById('catalogList');
const closeCatalog = document.getElementById('closeCatalog');
const addSamples = document.getElementById('addSamples');

let currentStream = null;
let gridVisible = false;
let useBackground = false;
let selectedItem = null;
let bgEditorActive = false;
let itemCounter = 0;

/* dynamic height for cameraWrapper to avoid iOS address bar issues */
function setCameraWrapperHeight(){
  const headerH = header.getBoundingClientRect().height || 64;
  const h = window.innerHeight - headerH;
  cameraWrapper.style.top = headerH + 'px';
  cameraWrapper.style.height = h + 'px';
  // resize grid canvas
  grid.width = Math.round(cameraWrapper.clientWidth);
  grid.height = Math.round(cameraWrapper.clientHeight);
  if(gridVisible) drawGrid(true);
}
window.addEventListener('resize', setCameraWrapperHeight);
window.addEventListener('orientationchange', ()=> { setTimeout(setCameraWrapperHeight,120); });
window.addEventListener('load', setCameraWrapperHeight);

/* ---------- Catalog inline SVGs (no external images) ---------- */
const ICONS = {
  "Sofa": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 320'><rect x='18' y='150' width='604' height='90' rx='18' fill='#111' opacity='0.95'/><rect x='60' y='100' width='200' height='80' rx='16' fill='#111'/><rect x='380' y='100' width='200' height='80' rx='16' fill='#111'/><rect x='40' y='240' width='20' height='40' rx='6' fill='#111'/><rect x='580' y='240' width='20' height='40' rx='6' fill='#111'/></svg>`,
  "Armchair": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 360 360'><rect x='60' y='80' width='240' height='120' rx='20' fill='#111' /><rect x='40' y='200' width='28' height='80' rx='6' fill='#111'/><rect x='292' y='200' width='28' height='80' rx='6' fill='#111'/></svg>`,
  "Table": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 360'><rect x='60' y='120' width='520' height='36' rx='10' fill='#111'/><rect x='120' y='156' width='24' height='140' rx='6' fill='#111'/><rect x='496' y='156' width='24' height='140' rx='6' fill='#111'/></svg>`,
  "Bed": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 720 360'><rect x='40' y='140' width='640' height='84' rx='14' fill='#111'/><rect x='70' y='100' width='240' height='60' rx='10' fill='#111' /><rect x='410' y='100' width='240' height='60' rx='10' fill='#111' /><rect x='40' y='224' width='640' height='32' rx='8' fill='#111' opacity='0.95'/></svg>`,
  "Lamp": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 240 480'><polygon points='120,36 210,150 30,150' fill='#111'/><rect x='116' y='150' width='8' height='220' rx='4' fill='#111'/><rect x='80' y='372' width='80' height='14' rx='6' fill='#111'/></svg>`,
  "Rug": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 360 240'><rect x='20' y='20' width='320' height='200' rx='20' fill='#111' opacity='0.07'/></svg>`,
  "Plant": `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 280 360'><rect x='100' y='260' width='80' height='60' rx='8' fill='#111'/><path d='M140 250 C120 220 120 200 140 180 C160 200 160 220 140 250Z' fill='#111'/></svg>`
};
function svgToDataUrl(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
function buildCatalog(){
  catalogList.innerHTML = '';
  for(const [name, svg] of Object.entries(ICONS)){
    const data = svgToDataUrl(svg);
    const card = document.createElement('div'); card.className='catalog-item';
    card.innerHTML = `<div class="catalog-thumb"><img src="${data}" alt="${name}"></div><div class="catalog-label">${name}</div><div class="catalog-sub">Tap to add</div>`;
    card.addEventListener('click', ()=> { createItem(data, {name}); closeCatalogDrawer(); });
    catalogList.appendChild(card);
  }
}
buildCatalog();

/* ---------- Grid ---------- */
function drawGrid(show){
  grid.width = Math.round(cameraWrapper.clientWidth);
  grid.height = Math.round(cameraWrapper.clientHeight);
  const ctx = grid.getContext('2d'); ctx.clearRect(0,0,grid.width,grid.height);
  if(!show) return;
  const gap = 48;
  ctx.strokeStyle = 'rgba(2,6,23,0.06)'; ctx.lineWidth = 1;
  for(let x=0;x<grid.width;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,grid.height); ctx.stroke(); }
  for(let y=0;y<grid.height;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(grid.width,y); ctx.stroke(); }
}
toggleGridBtn.addEventListener('click', ()=>{ gridVisible = !gridVisible; drawGrid(gridVisible); toggleGridBtn.textContent = gridVisible ? 'Grid: On' : 'Grid' });

/* ---------- Camera & background ---------- */
startCam.addEventListener('click', async ()=>{
  try{
    if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; camera.srcObject=null; }
    currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
    camera.srcObject = currentStream; camera.style.display = useBackground ? 'none' : 'block';
    bgImage.style.display = useBackground ? 'block' : 'none';
    await camera.play().catch(()=>{});
    setCameraWrapperHeight();
  }catch(err){ alert('Camera error: '+(err.message||err)); }
});
stopCam.addEventListener('click', ()=>{ if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; camera.srcObject=null; } });

uploadBg.addEventListener('click', ()=> fileBg.click());
fileBg.addEventListener('change', (e)=> {
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  bgImage.src = url; useBackground = true; bgImage.style.display = 'block'; camera.style.display = 'none';
  toggleCamBg.textContent = 'Use Camera';
  fileBg.value = '';
});

toggleCamBg.addEventListener('click', ()=>{
  useBackground = !useBackground;
  if(useBackground){ camera.style.display='none'; bgImage.style.display = bgImage.src ? 'block' : 'none'; toggleCamBg.textContent='Use Camera'; }
  else { camera.style.display='block'; bgImage.style.display='none'; toggleCamBg.textContent='Use Background'; }
});

/* ---------- Background editor (move/scale/commit/reset) ---------- */
editBgBtn.addEventListener('click', ()=>{
  if(!bgImage.src){ alert('Upload background first'); return; }
  // open editor
  bgEditorImg.src = bgImage.src;
  bgEditor.style.display = 'block';
  bgEditor.style.left = '50%'; bgEditor.style.top = '50%';
  bgEditor.dataset.tx = 0; bgEditor.dataset.ty = 0; bgEditor.dataset.scale = 1; bgEditor.dataset.rot = 0;
  bgEditorActive = true;
  // focus management so ARIA/hide warnings don't appear
  setInert(catalogDrawer, true);
  bgEditor.focus?.();
  makeBgEditorInteractive();
});

/* commit background (double-tap) is supported; also add keyboard shortcuts */
function commitBgEditor(){
  if(bgEditorImg.src){ bgImage.src = bgEditorImg.src; bgImage.style.display='block'; camera.style.display='none'; useBackground=true; toggleCamBg.textContent='Use Camera'; }
  bgEditor.style.display='none'; bgEditorActive = false;
  setInert(catalogDrawer, false);
}
function cancelBgEditor(){ bgEditor.style.display='none'; bgEditorActive=false; setInert(catalogDrawer, false); }
function resetBgEditor(){ bgEditorImg.style.transform = ''; bgEditor.dataset.tx=0; bgEditor.dataset.ty=0; bgEditor.dataset.scale=1; bgEditor.dataset.rot=0; bgEditorImg.src = bgImage.src || bgEditorImg.src; }

/* gestures for bg editor (pinch & pan) */
function makeBgEditorInteractive(){
  const wrap = bgEditor;
  const img = bgEditorImg;
  // ensure initial transform
  updateBgEditorTransform();
  let pointers = new Map();
  wrap.addEventListener('pointerdown', (e)=>{ pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); try{ wrap.setPointerCapture(e.pointerId);}catch(_){ } e.preventDefault(); });
  wrap.addEventListener('pointermove', (e)=>{
    if(!pointers.has(e.pointerId)) return;
    const prev = pointers.get(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(pointers.size===1){
      // pan
      const dx = e.clientX - prev.x, dy = e.clientY - prev.y;
      wrap.dataset.tx = parseFloat(wrap.dataset.tx||0) + dx;
      wrap.dataset.ty = parseFloat(wrap.dataset.ty||0) + dy;
      updateBgEditorTransform();
    } else {
      // pinch/rotate
      const pts = [...pointers.values()]; const a = pts[0], b = pts[1];
      const dist = Math.hypot(b.x-a.x,b.y-a.y);
      if(!wrap._baseDist){ wrap._baseDist = dist; wrap._baseScale = parseFloat(wrap.dataset.scale||1); wrap._baseAngle = Math.atan2(b.y-a.y,b.x-a.x); }
      else {
        const factor = dist / wrap._baseDist; wrap.dataset.scale = Math.max(0.1, wrap._baseScale * factor);
        const ang = Math.atan2(b.y-a.y,b.x-a.x); const delta = ang - wrap._baseAngle; wrap.dataset.rot = (parseFloat(wrap.dataset.rot||0) + delta*180/Math.PI);
        updateBgEditorTransform();
      }
    }
  });
  wrap.addEventListener('pointerup', (e)=>{ pointers.delete(e.pointerId); try{ wrap.releasePointerCapture(e.pointerId);}catch(_){ } if(pointers.size===0){ delete wrap._baseDist; delete wrap._baseScale; delete wrap._baseAngle; } });
  wrap.addEventListener('pointercancel', ()=>{ pointers.clear(); delete wrap._baseDist; delete wrap._baseScale; });

  // double click/tap to commit
  wrap.addEventListener('dblclick', ()=> commitBgEditor() );
}
/* helper */
function updateBgEditorTransform(){
  const wrap = bgEditor;
  wrap.style.transform = `translate(calc(-50% + ${wrap.dataset.tx||0}px), calc(-50% + ${wrap.dataset.ty||0}px)) scale(${wrap.dataset.scale||1}) rotate(${wrap.dataset.rot||0}deg)`;
}

/* ---------- Items: create, interact, toolbar ---------- */
function createItem(src, state={}){
  itemCounter++;
  const wrap = document.createElement('div'); wrap.className='item-wrap';
  wrap.dataset.id = 'item-'+itemCounter;
  wrap.dataset.tx = state.tx||0; wrap.dataset.ty = state.ty||0;
  wrap.dataset.scaleX = state.scaleX || 1; wrap.dataset.scaleY = state.scaleY || 1;
  wrap.dataset.rot = state.rot||0;
  // place center
  const rect = cameraWrapper.getBoundingClientRect();
  wrap.style.left = (rect.width/2) + 'px'; wrap.style.top = (rect.height/2) + 'px';

  const img = document.createElement('img'); img.className='item-img'; img.src = src; img.alt = state.name || 'item'; img.draggable=false;
  img.style.width = (state.w || Math.min(360, rect.width*0.32)) + 'px'; img.style.height = 'auto';

  // handles
  ['nw','n','ne','w','e','sw','s','se','rotate'].forEach(cl=>{
    const h = document.createElement('div'); h.className = 'handle ' + cl; wrap.appendChild(h);
  });

  // toolbar
  const toolbar = document.createElement('div'); toolbar.className='item-toolbar';
  const del = document.createElement('button'); del.className='tool'; del.textContent='Delete';
  const dup = document.createElement('button'); dup.className='tool'; dup.textContent='Duplicate';
  const up = document.createElement('button'); up.className='tool'; up.textContent='Bring ↑';
  const down = document.createElement('button'); down.className='tool'; down.textContent='Send ↓';
  toolbar.appendChild(del); toolbar.appendChild(dup); toolbar.appendChild(up); toolbar.appendChild(down);

  wrap.appendChild(img); wrap.appendChild(toolbar); overlay.appendChild(wrap);
  updateItemTransform(wrap);

  // interactions
  makeItemInteractive(wrap);

  // toolbar actions
  del.addEventListener('click', (e)=>{ e.stopPropagation(); wrap.remove(); if(selectedItem===wrap) selectedItem=null; });
  dup.addEventListener('click', (e)=>{ e.stopPropagation(); duplicateItem(wrap); });
  up.addEventListener('click', (e)=>{ e.stopPropagation(); bringForward(wrap); });
  down.addEventListener('click', (e)=>{ e.stopPropagation(); sendBackward(wrap); });

  // focus selected
  selectItem(wrap);
  return wrap;
}
function updateItemTransform(wrap){
  const tx = parseFloat(wrap.dataset.tx||0), ty = parseFloat(wrap.dataset.ty||0);
  const sx = parseFloat(wrap.dataset.scaleX||1), sy = parseFloat(wrap.dataset.scaleY||1);
  const rot = parseFloat(wrap.dataset.rot||0);
  wrap.style.transform = `translate(-50%,-50%) translate(${tx}px, ${ty}px) scale(${sx}, ${sy}) rotate(${rot}deg)`;
}
function selectItem(wrap){
  qsa('.item-wrap').forEach(i=>i.classList.remove('selected'));
  if(wrap){ wrap.classList.add('selected'); selectedItem = wrap; }
  else selectedItem=null;
}

/* Interactions: drag, pinch, resize, rotate */
function makeItemInteractive(wrap){
  const img = wrap.querySelector('img');

  // click -> select and start drag (if not handle)
  wrap.addEventListener('pointerdown', (e)=>{ if(e.target.classList.contains('handle')) return; selectItem(wrap); startDrag(e,wrap); });

  // dblclick to delete
  wrap.addEventListener('dblclick', ()=>{ wrap.remove(); if(selectedItem===wrap) selectedItem=null; });

  // handle pointerdown for resize/rotate
  Array.from(wrap.querySelectorAll('.handle')).forEach(h=>{
    h.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); if(h.classList.contains('rotate')) startRotate(ev,wrap); else startResize(ev,wrap,h); });
  });

  // multi-touch pinch/rotate
  (function(){
    const map = new Map();
    wrap.addEventListener('pointerdown', (e)=>{ map.set(e.pointerId,{x:e.clientX,y:e.clientY}); try{ wrap.setPointerCapture(e.pointerId);}catch(_){ } });
    wrap.addEventListener('pointermove', (e)=>{
      if(!map.has(e.pointerId)) return;
      map.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(map.size>=2){
        const pts = Array.from(map.values());
        const a = pts[0], b = pts[1];
        const dist = Math.hypot(b.x-a.x,b.y-a.y);
        const angle = Math.atan2(b.y-a.y,b.x-a.x);
        if(!wrap._baseDist){ wrap._baseDist = dist; wrap._baseScaleX = parseFloat(wrap.dataset.scaleX||1); wrap._baseScaleY = parseFloat(wrap.dataset.scaleY||1); wrap._baseAngle = angle; wrap._baseRot = parseFloat(wrap.dataset.rot||0); }
        else {
          const factor = dist / wrap._baseDist;
          wrap.dataset.scaleX = Math.max(0.05, wrap._baseScaleX * factor);
          wrap.dataset.scaleY = Math.max(0.05, wrap._baseScaleY * factor);
          const delta = (angle - wrap._baseAngle) * 180 / Math.PI;
          wrap.dataset.rot = wrap._baseRot + delta;
          updateItemTransform(wrap);
        }
      }
    });
    wrap.addEventListener('pointerup', (e)=>{ map.delete(e.pointerId); try{ wrap.releasePointerCapture(e.pointerId);}catch(_){ } if(map.size===0){ delete wrap._baseDist; } });
    wrap.addEventListener('pointercancel', ()=>{ map.clear(); delete wrap._baseDist; });
  })();
}

/* drag */
function startDrag(e, wrap){
  e.preventDefault();
  selectItem(wrap);
  const startX = e.clientX, startY = e.clientY;
  const startTx = parseFloat(wrap.dataset.tx||0), startTy = parseFloat(wrap.dataset.ty||0);
  function move(ev){ wrap.dataset.tx = startTx + (ev.clientX - startX); wrap.dataset.ty = startTy + (ev.clientY - startY); updateItemTransform(wrap); }
  function up(){ window.removeEventListener('pointermove', move); window.removeEventListener('pointerup', up); }
  window.addEventListener('pointermove', move); window.addEventListener('pointerup', up);
}

/* resize (corner/side). Proportional by default; Shift key for freeform - mobile: touch-based freeform */
function startResize(e, wrap, handleEl){
  e.preventDefault();
  const img = wrap.querySelector('img');
  const rect = img.getBoundingClientRect();
  const baseW = rect.width, baseH = rect.height;
  const sx0 = parseFloat(wrap.dataset.scaleX||1), sy0 = parseFloat(wrap.dataset.scaleY||1);
  const startX = e.clientX, startY = e.clientY;
  const rot = parseFloat(wrap.dataset.rot||0) * Math.PI/180;
  function move(ev){
    const dx = ev.clientX - startX, dy = ev.clientY - startY;
    // rotate-aware coords
    const cos = Math.cos(rot), sin = Math.sin(rot);
    const localX = dx * cos + dy * sin;
    const localY = -dx * sin + dy * cos;
    let newW = baseW * sx0, newH = baseH * sy0;
    const cls = handleEl.classList;
    if(cls.contains('e')) newW += localX;
    if(cls.contains('w')) newW -= localX;
    if(cls.contains('s')) newH += localY;
    if(cls.contains('n')) newH -= localY;
    // corner: we preserve aspect ratio
    if(cls.contains('nw')||cls.contains('ne')||cls.contains('sw')||cls.contains('se')){
      const aspect = baseW/baseH;
      if(newW / newH > aspect) newH = newW / aspect; else newW = newH * aspect;
    }
    const MIN = 30;
    if(newW < MIN) newW = MIN; if(newH < MIN) newH = MIN;
    wrap.dataset.scaleX = (newW/baseW).toString();
    wrap.dataset.scaleY = (newH/baseH).toString();
    updateItemTransform(wrap);
  }
  function up(){ window.removeEventListener('pointermove', move); window.removeEventListener('pointerup', up); }
  window.addEventListener('pointermove', move); window.addEventListener('pointerup', up);
}

/* rotate */
function startRotate(e, wrap){
  e.preventDefault();
  const rect = wrap.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const start = Math.atan2(e.clientY - cy, e.clientX - cx);
  const base = parseFloat(wrap.dataset.rot || 0);
  function move(ev){ const ang = Math.atan2(ev.clientY - cy, ev.clientX - cx); wrap.dataset.rot = base + (ang - start) * 180/Math.PI; updateItemTransform(wrap); }
  function up(){ window.removeEventListener('pointermove', move); window.removeEventListener('pointerup', up); }
  window.addEventListener('pointermove', move); window.addEventListener('pointerup', up);
}

/* duplicate & z-order */
function duplicateItem(wrap){
  const clone = wrap.cloneNode(true);
  clone.dataset.id = 'item-'+(++itemCounter);
  clone.dataset.tx = (parseFloat(wrap.dataset.tx||0) + 20).toString();
  clone.dataset.ty = (parseFloat(wrap.dataset.ty||0) + 20).toString();
  overlay.appendChild(clone);
  updateItemTransform(clone);
  makeItemInteractive(clone);
  selectItem(clone);
}
function bringForward(wrap){ const next = wrap.nextElementSibling; if(next) wrap.parentNode.insertBefore(next, wrap); }
function sendBackward(wrap){ const prev = wrap.previousElementSibling; if(prev) wrap.parentNode.insertBefore(wrap, prev); }

/* ---------- Snapshot composed to exact visible view ---------- */
snapshotBtn.addEventListener('click', async ()=>{
  const rect = cameraWrapper.getBoundingClientRect();
  const cw = Math.max(1, Math.round(rect.width)), ch = Math.max(1, Math.round(rect.height));
  const c = document.createElement('canvas'); c.width = cw; c.height = ch; const ctx = c.getContext('2d');

  // background: editor committed -> bgImage, else video -> camera, else white
  if(useBackground && bgImage.src && bgImage.style.display !== 'none'){
    const img = await loadImage(bgImage.src);
    // draw cover
    ctx.drawImage(img, 0, 0, cw, ch);
  } else if(camera && camera.videoWidth){
    drawVideoCover(camera, ctx, cw, ch);
  } else {
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,cw,ch);
  }

  // grid if visible
  if(gridVisible){ const gap = 48; ctx.strokeStyle='rgba(2,6,23,0.06)'; ctx.lineWidth=1; for(let x=0;x<cw;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ch); ctx.stroke(); } for(let y=0;y<ch;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cw,y); ctx.stroke(); } }

  // draw items in DOM order (z-order)
  const items = Array.from(overlay.querySelectorAll('.item-wrap'));
  for(const w of items){
    const im = w.querySelector('img'); if(!im) continue;
    const image = await loadImage(im.src);
    const r = im.getBoundingClientRect();
    const cameraRect = cameraWrapper.getBoundingClientRect();
    const x = r.left - cameraRect.left, y = r.top - cameraRect.top, wdt = r.width, hgt = r.height;
    const centerX = x + wdt/2, centerY = y + hgt/2;
    const rot = parseFloat(w.dataset.rot||0) * Math.PI/180;
    ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(rot); ctx.drawImage(image, -wdt/2, -hgt/2, wdt, hgt); ctx.restore();
  }

  // download
  const a = document.createElement('a'); a.href = c.toDataURL('image/png'); a.download = 'demo-tryon.png'; a.click();
});
function drawVideoCover(video, ctx, cw, ch){
  const vw = video.videoWidth, vh = video.videoHeight;
  if(!vw||!vh) return;
  const scale = Math.max(cw/vw, ch/vh);
  const sw = cw/scale, sh = ch/scale, sx=(vw-sw)/2, sy=(vh-sh)/2;
  ctx.drawImage(video, sx, sy, sw, sh, 0,0,cw,ch);
}
function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(i); i.src=src; }); }

/* ---------- Catalog open/close with inert/fallback ---------- */
catalogToggle.addEventListener('click', ()=> openCatalogDrawer());
closeCatalog.addEventListener('click', ()=> closeCatalogDrawer());
function openCatalogDrawer(){ catalogDrawer.classList.add('open'); setInert(document.body, true, [catalogDrawer]); catalogToggle.setAttribute('aria-expanded','true'); closeCatalog.focus(); }
function closeCatalogDrawer(){ // if focused element is inside drawer, move focus before hiding to avoid aria-hidden warning
  const active = document.activeElement;
  if(catalogDrawer.contains(active)) catalogToggle.focus(); catalogDrawer.classList.remove('open'); setInert(document.body, false); catalogToggle.setAttribute('aria-expanded','false'); }

/* inert polyfill-ish: if browser supports element.inert use it; else fallback to aria-hidden + manage focusable elements.
   containerToLeave array contains nodes that should remain interactive (e.g., drawer when open) */
function setInert(root, inert, containerToLeave=[]){
  if('inert' in document.body){ // native support
    // mark everything inert except containerToLeave nodes
    const all = Array.from(document.body.children);
    all.forEach(node=>{
      if(containerToLeave.includes(node)) { node.inert = false; node.removeAttribute('aria-hidden'); }
      else node.inert = inert;
    });
    return;
  }
  // fallback: set aria-hidden on siblings that should be hidden or not
  // If inert true, add aria-hidden to everything except allowed roots
  const allowed = new Set(containerToLeave);
  const children = Array.from(document.body.children);
  children.forEach(child=>{
    if(allowed.has(child)) { child.removeAttribute('aria-hidden'); enableTabIndex(child, true); }
    else { if(inert) child.setAttribute('aria-hidden','true'); else child.removeAttribute('aria-hidden'); enableTabIndex(child, !inert); }
  });

  function enableTabIndex(node, enable){
    // toggle tabindex on focusable descendants; when inert we set tabindex=-1 to avoid focus
    const selectors = 'a,button,input,select,textarea,[tabindex]';
    const focusables = Array.from(node.querySelectorAll(selectors));
    focusables.forEach(el=>{
      if(enable) {
        if(el.__savedTabIndex !== undefined){ el.setAttribute('tabindex', el.__savedTabIndex); delete el.__savedTabIndex; }
        else el.removeAttribute('tabindex');
      } else {
        if(el.hasAttribute('tabindex')) el.__savedTabIndex = el.getAttribute('tabindex');
        el.setAttribute('tabindex','-1');
      }
    });
  }
}

/* ---------- AR entry button: show/hide based on support ---------- */
(async function checkAR(){
  if(navigator.xr && navigator.xr.isSessionSupported){
    const ok = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
    if(!ok) enterArBtn.disabled = true;
  } else {
    // iOS Safari often lacks WebXR; disable
    enterArBtn.disabled = true;
  }
})();
enterArBtn.addEventListener('click', async ()=>{
  if(!navigator.xr) { alert('AR not available on this device/browser.'); return; }
  try{
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    if(!supported){ alert('AR not supported on this device.'); return; }
    const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures:['hit-test'] });
    // This is a stub: we start the session; integrating 3D rendering is a separate task.
    alert('AR session started (prototype). Implement model rendering and hit-test placement for production.');
    // session end handler
    session.addEventListener('end', ()=> alert('AR session ended.'));
  }catch(err){ console.error(err); alert('Failed to enter AR: '+(err.message||err)); }
});

/* ---------- Upload furniture ---------- */
uploadFurniture.addEventListener('click', ()=> fileFurniture.click());
fileFurniture.addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  createItem(url, {name: f.name});
  // also add to catalog (so user can reuse)
  addCustomToCatalog(f.name, url);
  fileFurniture.value = '';
});
function addCustomToCatalog(name, src){
  const card = document.createElement('div'); card.className='catalog-item';
  card.innerHTML = `<div class="catalog-thumb"><img src="${src}" alt="${name}"></div><div class="catalog-label">${name}</div><div class="catalog-sub">Uploaded</div>`;
  card.addEventListener('click', ()=> { createItem(src, {name}); closeCatalogDrawer(); });
  catalogList.appendChild(card);
}

/* ---------- Duplicate & Z-order functions (already available) ---------- */

/* ---------- Helper to get all qsa ---------- */
function qsa(sel){ return Array.from(document.querySelectorAll(sel)); }

/* ---------- Utility: load initial samples ---------- */
document.getElementById('addSamples').addEventListener('click', ()=>{
  const entries = Object.entries(ICONS);
  entries.forEach(([k,v],i)=>{
    const data = svgToDataUrl(v);
    const it = createItem(data,{name:k});
    it.dataset.tx = (i-1)*60; it.dataset.ty = Math.abs(i-1)*18;
    updateItemTransform(it);
  });
  closeCatalogDrawer();
});

/* ---------- Duplicate click handlers for safety ---------- */
resetBtn.addEventListener('click', ()=> { overlay.innerHTML = ''; selectedItem=null; bgImage.src=''; bgImage.style.display='none'; camera.style.display='block'; useBackground=false; });

/* ---------- helper image loader ---------- */
function loadImage(src){ return new Promise(res=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(i); i.src=src; }); }

/* ---------- focus handling: clicking outside deselects items ---------- */
document.addEventListener('click', (e)=>{
  if(!overlay.contains(e.target) && !e.target.closest('.catalog-item') && !catalogDrawer.contains(e.target) && !catalogToggle.contains(e.target)){
    if(selectedItem) { selectedItem.classList.remove('selected'); selectedItem=null; }
  }
});

/* ensure header + camera wrapper height set initially */
setCameraWrapperHeight();

/* Prevent double-tap to zoom on iOS when interacting with overlay */
document.addEventListener('touchstart', function(e){ if(e.touches.length>1) e.preventDefault(); }, { passive:false });
</script>
</body>
</html>
